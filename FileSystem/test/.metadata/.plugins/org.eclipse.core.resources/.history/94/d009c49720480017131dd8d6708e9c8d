/*
 * globalfifo.c
 *
 *  Created on: 2017年6月3日
 *      Author: tusen
 */

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/printk.h>
#include <linux/moduleparam.h>
#include <linux/input.h>
#include <linux/platform_device.h>


#define GLOBALFIFO_SIZE   0x1000
#define MEM_CLEAR        0x01
#define GLOBALFIFO_MAJOR  230


static int  globalfifo_major=GLOBALFIFO_MAJOR;
//module_param(globalfifo_major,int ,S_IRUGO);



struct globalfifo_dev{
	struct cdev cdev;
	unsigned int current_len;
	unsigned char mem[GLOBALFIFO_SIZE];
	struct mutex mutex;
	wait_queue_head_t r_wait;
	wait_queue_head_t w_wait;
};
struct globalfifo_dev *globalfifo_devp;


static ssize_t globalfifo_read (struct file *filp,char __user *buf,size_t size,
		loff_t * ppos)
{
	int ret =0;
	struct globalfifo_dev  *dev=filp->private_data;
	DECLARE_WAITQUEUE(wait,current);

	/* 获取互次量 */
	mutex_lock(&dev->mutex);
	add_wait_queue(&dev->r_wait,&wait);

	unsigned long p = *ppos; //读取文件的位置 偏移
	unsigned int  count=size;//读取文件内的字节数

	if(p>=GLOBALFIFO_SIZE)
		return 0;

	if(count > GLOBALFIFO_SIZE-p)
		count=GLOBALFIFO_SIZE-p;



	if( copy_to_user(buf,dev->mem+p,count) ){
		ret=-EFAULT;
	} else {
		*ppos+=count;
		ret=count;

		printk(KERN_INFO "read %u byte(s) from %lu \n",count ,p);
	}

	/* 释放互斥量 */
	mutex_unlock(&dev->mutex);

	return ret;
}


static ssize_t globalfifo_write(struct file *filp, const char __user *buf,
		size_t size,loff_t *ppos)
{
	unsigned long p = *ppos;
	unsigned int count = size;
	int ret =0;
	struct globalfifo_dev *dev=filp->private_data;


	if(p >= GLOBALFIFO_SIZE )
		return 0;

	if(count >GLOBALFIFO_SIZE-p) //p 是文件偏移量
		count = GLOBALFIFO_SIZE-p;

	/* 获取互次量 */
	mutex_lock(&dev->mutex);

	if(copy_from_user(dev->mem+p,buf,count))
		ret=-EFAULT;
	else {
		*ppos+=count;
		ret = count;

		printk(KERN_INFO "written %u byte(s) from %lu \n",count,p);
	}

	/* 释放互斥量 */
	mutex_unlock(&dev->mutex);

	return ret;
}



static loff_t globalfifo_llseek(struct file * filp,loff_t offest,int orig)
{
	loff_t ret=0;
	switch (orig){
	case 0:/* 从文件开头位置seek */
		if(offest<0){
			ret=-EINVAL;
			break;
		}
		if((unsigned int )offest > GLOBALFIFO_SIZE){
			ret=-EINVAL;
			break;
		}
		filp->f_pos=(unsigned int) offest;
		ret=filp->f_pos;
		break;
	case 1:
		if ( (filp->f_pos + offest) > GLOBALFIFO_SIZE  ){
			ret =-EINVAL;
			break;
		}
		if( filp->f_pos + offest < 0 ){
			ret =-EINVAL;
			break;
		}
		filp->f_pos+=offest;
		ret =filp->f_pos;
		break;
	default :
		ret = -EINVAL;
		break;
	}
	return ret;
}


static long globalfifo_ioctl (struct file *filp,unsigned int cmd,
		unsigned long arg)
{
	struct globalfifo_dev *dev = filp->private_data;

	switch (cmd){
	case MEM_CLEAR:
		/* 获取互次量 */
		mutex_lock(&dev->mutex);

		memset(dev->mem,0,GLOBALFIFO_SIZE);

		/* 释放互斥量 */
		mutex_unlock(&dev->mutex);

		printk( KERN_INFO "globalfifo is set to zero \n" );
		break;

	default:
		return -EINVAL;
	}
	return 0;
}



static int globalfifo_open( struct inode *inode ,struct file *filp )
{
	filp->private_data=globalfifo_devp;
	return 0;
}


static int globalfifo_release(struct inode *inode , struct file *filp)
{

	return 0;
}



static const struct file_operations globalfifo_fops = {
		.owner = THIS_MODULE,
		.llseek = globalfifo_llseek,
		.read = globalfifo_read,
		.write = globalfifo_write,
		.unlocked_ioctl = globalfifo_ioctl,
		.open = globalfifo_open,
		.release = globalfifo_release,
};



static void  globalfifo_setup_cdev(struct globalfifo_dev *dev,int index)
{
	int err ,devno=MKDEV(globalfifo_major,index);

	cdev_init(&dev->cdev,&globalfifo_fops);

	dev->cdev.owner=THIS_MODULE;
	err=cdev_add(&dev->cdev,devno,1);
	if(err)
		printk(KERN_NOTICE "Error %d adding globalfifo%d",err,index);

}


static int __init globalfifo_init (void)
{
	int ret;
	dev_t devno=MKDEV(globalfifo_major,0);

	if(globalfifo_major)
		//分配 (globalfifo_major：0)  开始的1个设备号出来
		//name=globalfifo：这个的设备的名字; 它会出现在 /proc/devices 和 sysfs 中.
		ret=register_chrdev_region(devno,1,"globalfifo_dev");
	else{
		//系统自动分配以 从设备号为0开始的一个设备号出来，然后将完整的设备号放入 devno中
		ret=alloc_chrdev_region(&devno,0,1,"globalfifo_dev");
		globalfifo_major=MAJOR(devno);
	}
	if(ret<0)
		return ret;

	/* 分配设备结构体的空间 */
	globalfifo_devp =kzalloc(sizeof(struct globalfifo_dev),GFP_KERNEL);
	if(!globalfifo_devp) {
		ret = -ENOMEM;
		goto faill_malloc;
	}


	globalfifo_setup_cdev(globalfifo_devp,0);

	mutex_init(&globalfifo_devp->mutex);
	init_waitqueue_head(&globalfifo_devp->r_wait);
	init_waitqueue_head(&globalfifo_devp->w_wait);

	return 0;

	faill_malloc:
	unregister_chrdev_region(devno,1);
	return ret;
}




static int __exit globalfifo_exit(void)
{
	cdev_del(&globalfifo_devp->cdev);
	kfree(globalfifo_devp);
	unregister_chrdev_region(MKDEV(globalfifo_major,0),1);
	return 0;
}


module_init(globalfifo_init);
module_exit(globalfifo_exit);



MODULE_AUTHOR("Tu_sen");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION(" Use the meme to globalfifo driver ");
MODULE_ALIAS(" a simple globalfifo device ");



