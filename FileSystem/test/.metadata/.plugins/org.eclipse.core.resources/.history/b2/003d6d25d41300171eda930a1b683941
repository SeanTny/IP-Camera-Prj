/*
 * show_font.c
 *
 *  Created on: 2017年3月26日
 *      Author: tusen
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/fb.h>
#include <unistd.h>
#include <sys/mman.h>
#include <wchar.h>
#include <math.h>
#include <wchar.h>
#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_GLYPH_H


extern const unsigned char fontdata_8x16[4096];

int fd_fb;
int fd_HZK16;
struct fb_var_screeninfo var;
struct fb_fix_screeninfo fix;
struct stat hzk_stat;
unsigned int line_width;
unsigned int pixel_width;
int screen_size;
unsigned char * fbmem;
unsigned char * hzkmem;


/* 显示一个像素 */
/* color is ARGB format:0x00RRGGBB */
void lcd_put_pixel (int x,int y,unsigned int color)
{
	unsigned char  * pen_8=fbmem+y*line_width+x*pixel_width;
	unsigned short * pen_16;
	unsigned int   * pen_32;

	unsigned int 	red,green,blue;

	pen_16=(unsigned short *)pen_8;
	pen_32=(unsigned int   *)pen_8;

	switch(var.bits_per_pixel)
	{
	case 8:
		*pen_8=color;
		break;
	case 16:
		/* RGB 565 */
		red=  (color>>16)&0xff;
		green=(color>>8)&0xff;
		blue= (color>>0)&0xff;
		color=((red>>3)<<11|((green>>2)<<5)|(blue>>3));
		*pen_16=color;
		break;
	case 32:
		*pen_32=color;
		break;
	default:
		printf("not surport %d bpp \n",var.bits_per_pixel);
		break;
	}
}

/* 往显示器上面显示一个汉字 */
void lcd_put_chinese(int x,int y,unsigned char* str)
{
	unsigned int area=str[0]-0xA1;
	unsigned int where=str[1]-0xA1;
	unsigned char * dots=hzkmem+(area*94+where)*32;
	unsigned char byte;

	int i,j,b;
	for(i=0;i<16;i++){
		for(j=0;j<2;j++){
			byte=dots[i*2+j];
			for(b=7;b>=0;b--){
				if(byte & (1<<b) ){
					/* show */
					lcd_put_pixel(x+j*8+7-b,y+i,0xffffff);//白
				}else{
					/* hide */
					lcd_put_pixel(x+j*8+7-b,y+i,0x000000);//黑
				}
			}
		}
	}
}


/* 往LCD上面显示一个ascii字符 */
void lcd_put_ascii(int x, int y,unsigned char c ){
	unsigned char * dots=(unsigned char *) &fontdata_8x16[c*16];
	int i,b;
	unsigned char byte ;

	for(i=0;i<16;i++){
		byte=dots[i];
		for(b=7;b>=0;b--){
			if(byte & (1<<b)){
				/* show */
				lcd_put_pixel(x+7-b,y+i,0xffffff);/* 白 */
			}else{
				/* hide */
				lcd_put_pixel(x+7-b,y+i,0x000000);/* 黑 */
			}
		}
	}
}


void
draw_bitmap( FT_Bitmap*  bitmap,
             FT_Int      x,
             FT_Int      y)
{
  FT_Int  i, j, p, q;
  FT_Int  x_max = x + bitmap->width;
  FT_Int  y_max = y + bitmap->rows;


	//printf("x = %d, y = %d\n", x, y);

  for ( i = x, p = 0; i < x_max; i++, p++ )
  {
    for ( j = y, q = 0; j < y_max; j++, q++ )
    {
      if ( i < 0      || j < 0       ||
           i >= var.xres || j >= var.yres )
        continue;
      //image[j][i] |= bitmap->buffer[q * bitmap->width + p];
      lcd_put_pixel(i,j,bitmap->buffer[q*bitmap->width+p]);
    }
  }
}

/* 主涵数的地方 */
int main(int argc, char** argv){

	int number=3;
	printf("hello test the number is : %d \n",number);

	wchar_t  *wstr1=L"百问网gif";
	wchar_t  *str2 =L"";

	FT_Library	  library;
	FT_Face 	  face;
	FT_GlyphSlot  slot;
	FT_Matrix	  matrix;				  /* transformation matrix */
    FT_Vector     pen;
	int 		  error;
	double        angle;

	if (argc != 3){
		printf("Usage : %s <font_file> <angle>\n", argv[0]);
		return -1;
	}

	/* 打开显存 */
	fd_fb=open("/dev/fb0",O_RDWR);
	if(fd_fb < 0){
		printf("can`t open /dev/fb0 \n");
		return -1;
	}

	if(ioctl(fd_fb,FBIOGET_VSCREENINFO, &var)){
		printf("can`t get var \n");
		return -1;
	}

	if (ioctl(fd_fb,FBIOGET_VSCREENINFO,&fix)){
		printf("can`t get fix \n");
		return -1;
	}

	/* 屏幕的参数计算 */
	line_width=var.xres*var.bits_per_pixel/8; 			//宽的字节数
	pixel_width=var.bits_per_pixel/8;					//每一个像素占用的字节数
	screen_size =var.xres*var.yres*var.bits_per_pixel/8;//显存的字节数
	fbmem=(unsigned char *)mmap(NULL,screen_size,PROT_READ|PROT_WRITE, MAP_SHARED,fd_fb,0);
	if(fbmem==(unsigned char *)-1){
		printf("can`t mmap \n");
		return -1;
	}


	//====================================================
	fd_HZK16=open("./HZK16",O_RDONLY);
	if(fd_HZK16<0){
		printf("can`t open HZK_16 \n");
		return -1;
	}

	if(fstat(fd_HZK16,&hzk_stat)){
		printf("can`t get hzk stat \n");
		return -1;
	}

	hzkmem=(unsigned char *)mmap(NULL,hzk_stat.st_size,PROT_READ,MAP_SHARED,fd_HZK16,0);
	if(hzkmem==(unsigned char * )-1){
		printf("can`t mmap for hzk16_memfdf\n");
		return -1;
	}

	/* 对映射的内存进行操作 */
	memset(fbmem,0x10,screen_size); //black: 黑色


	/* 显示矢量字体 */
	error=FT_Init_FreeType(&library);

	error=FT_New_Face(library,argv[1],0,&face);

	slot=face->glyph;

	FT_Set_Pixel_Sizes(face,24,0);
	/* 确定坐标：
	 * lcd_x=var.xres/2+8+16;
	 * lcd_y=var.yres/2+16
	 * 迪卡尔坐标系：
	 * x=lcd_x         =var.xres/2 + 8 + 16
	 * y=var.yres-lcd_y=var.yres/2-16;
	 * */
	pen.x=(0) * 64;
	pen.y=(var.yres-24)*64;

	angle = ( 1.0 * strtoul(argv[2], NULL, 0) / 360 ) * 3.14159 * 2;	  /*  类型转换成unsigned long 类型 */
	/* set up matrix */
	matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
	matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
	matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
	matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

    /* set transformation */
    //FT_Set_Transform( face, &matrix, &pen);
	FT_Set_Transform( face, 0, &pen);





	error=FT_Load_Char(face,chinese_str[0],FT_LOAD_RENDER);
	if(error){
		printf("FT load_char error \n");
		return -1;
	}

	draw_bitmap(&slot->bitmap,slot->bitmap_left,var.yres-slot->bitmap_top);

	close(fd_HZK16);
	close(fd_fb);
	return 0;
}














































